<!DOCTYPE html>
<html style="overflow: hidden; margin: 0%; padding: 0%;">
<head>    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-wrapper {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body style="overflow: hidden; margin: 0%; padding: 0%;">
    <div id="canvas-container" style="margin: 0%; padding: 0%; width: 100vw; height: 100vh;">
        <canvas id="c" width="800" height="600" style="display: block; margin: 0%; padding: 0%;"></canvas>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="logic.js"></script>
<script src="styling.js"></script>
<script>
    const canvas = new fabric.Canvas('c', {
        selection: false, // Disable the blue group selection box globally
        hoverCursor: 'default',
        backgroundColor: '#26285D'
    });

    const assetUrls = {
        wolvey: 'images.png',
        meme1: 'images.png',
        meme2: 'images.png',
        meme3: 'images.png',
        meme4: 'images.png',
        meme5: 'images.png'
    };

    // Game State
    const assets = {
        wolvey: null,
        storeItems: [],
        images: {}
    };

    // UI Constants
    const COLORS = {
        leftBg: '#1a232e', // Dark Blue
        midBg: '#0d1218',  // Darker Blue/Black
        rightBg: '#F6CF47',
        text: '#26285D',
        accent: '#66cdaa',
        storeHover: '#f8da6d',
        storeBg: '#F6CF47',
        storeClick: '#dbae0a',
        upgradeBg: '#424eb9',
        upgradeHover: '#6F76B4'
    };

    /**
     * Preloads a list of images so they are cached and ready to use.
     * @param {string[]} urls - An array of image strings/URLs.
     */
    // --- 1. PRELOADER UTILITY (UPDATED) ---
    function preloadAssets(assetsToLoad) {
        // We map over the Keys now, not just a list of URLs
        const promises = Object.keys(assetsToLoad).map(key => {
            const url = assetsToLoad[key];
            return new Promise((resolve) => {
                const img = new Image();
                img.src = url;
                // We pass back the KEY so we know which image this is
                img.onload = () => resolve({ key: key, success: true, element: img });
                img.onerror = () => {
                    console.warn(`Failed to load asset '${key}': ${url}`);
                    resolve({ key: key, success: false, element: null });
                };
            });
        });

        return Promise.all(promises).then(results => {
            const loadedAssets = {};
            results.forEach(item => {
                if (item.success) {
                    // Reconstruct the object: { cookieIcon: <img element> }
                    loadedAssets[item.key] = item.element;
                }
            });
            assets["images"] = loadedAssets;
        });
    }

    // --- OBJECT CREATION ---

    // 1. Background Panels (Visual separation)
    const panelMid = new fabric.Rect({ left: 0, top: 0, fill: COLORS.midBg, selectable: false, evented: false });
    const panelRight = new fabric.Rect({ left: 0, top: 0, fill: COLORS.rightBg, opacity: 0.6, selectable: false, evented: false });
    // Divider lines
    const div2 = new fabric.Rect({ top: 0, width: 6, fill: 'rgba(0,0,0,0.5)', selectable: false, evented: false });

    canvas.add(panelRight, div2);

    // 2. Score Text
    const scoreLabel = new fabric.Text('0 MDP Credits', {
        fontFamily: 'Comic Sans MS, Arial, sans-serif',
        fontSize: 40,
        fill: '#ffffff',
        textAlign: 'center',
        selectable: false,
        evented: false,
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 10, offsetX: 2, offsetY: 2 })
    });
    const cpsLabel = new fabric.Text('per second: 0', {
        fontFamily: 'Arial, sans-serif',
        fontSize: 18,
        fill: '#aaaaaa',
        textAlign: 'center',
        selectable: false,
        evented: false
    });
    canvas.add(scoreLabel, cpsLabel);

    // 3. Store Title
    const storeTitle = new fabric.Text('STORE', {
        fontFamily: 'Comic Sans MS, Arial, sans-serif',
        fontSize: 24,
        fontWeight: 'bold',
        fill: COLORS.text,
        selectable: false,
        evented: false
    });
    canvas.add(storeTitle);


    // 4. Helper to create a Store Item Button
    function createStoreItem(name, price, creditsPerSecond, iconImg, flavorTxt, index) {
        itemTracker[index].cost = price
        itemTracker[index].creditsPerSecond = creditsPerSecond

        const height = 100;
        const padding = 10;
        
        // Container Box
        const bg = new fabric.Rect({
            width: 280, // Will be resized in layout
            height: height - padding,
            fill: COLORS.storeBg,
            rx: 5, ry: 5,
            stroke: '#333',
            strokeWidth: 1
        });

        const icon = new fabric.Image(iconImg, {
            crossOrigin: "anonymous",
            left: 10,
            top: 10,
            scaleX: 0.2,
            scaleY: 0.2
        });

        // Name
        const nameText = new fabric.Text(name, {
            fontFamily: 'Arial',
            fontSize: 20,
            fill: COLORS.text,
            left: 70,
            top: 10,
            fontWeight: 'bold'
        });

        // Price
        const priceText = new fabric.Text(`ðŸ“ ${price}`, {
            fontFamily: 'Arial',
            fontSize: 16,
            fill: COLORS.text,
            left: 70,
            top: 35
        });

        // Flavor
        const flavorText = new fabric.Text(`\"${flavorTxt}\"`, {
            fontFamily: 'Arial',
            fontSize: 12,
            fontStyle: "italic",
            fill: COLORS.text,
            left: 10,
            top: 65
        });

        // Count
        const countText = new fabric.Text(`x0`, {
            fontFamily: 'Arial',
            fontSize: 35,
            fontStyle: "bold",
            fill: COLORS.text,
            left: 160,
            top: 20
        });

        // per second
        const cpsText = new fabric.Text(`${creditsPerSecond}/s`, {
            fontFamily: 'Arial',
            fontSize: 12,
            fontStyle: "bold",
            fill: COLORS.text,
            left: 0,
            top: 0
        });

        // Upgrade button
        const upgradeButton = createUpgradeButton(index, cpsText)

        // Group them
        const group = new fabric.Group([bg, icon, nameText, priceText, flavorText, countText, cpsText, upgradeButton], {
            left: 0, // Set in layout
            top: 0,  // Set in layout
            selectable: false, // LOCKED: User can't move the button
            hoverCursor: 'pointer',
            subTargetCheck: true,
            name: 'storeButton'
        });

        // Custom properties for logic
        group.origFill = COLORS.storeBg;
        
        // Add interaction
        group.on('mouseover', (opt) => {
            if (opt.subTargets && opt.subTargets.includes(upgradeButton)) {
                return; // STOP HERE. Do not run the code below.
            }
            bg.set('fill', COLORS.storeHover);
            canvas.requestRenderAll();
        });
        group.on('mouseout', () => {
            bg.set('fill', COLORS.storeBg);
            canvas.requestRenderAll();
        });
        group.on('mousedown', (opt) => {
            if (opt.subTargets && opt.subTargets.includes(upgradeButton)) {
                return; // STOP HERE. Do not run the code below.
            }
            bg.set('fill', COLORS.storeClick);
            canvas.requestRenderAll();
        });
        group.on('mouseup', (opt) => {
            if (opt.subTargets && opt.subTargets.includes(upgradeButton)) {
                return; // STOP HERE. Do not run the code below.
            }

            bg.set('fill', COLORS.storeHover);
            // increase count
            countText.set('text', `x${++itemTracker[index].count}`)
            // increase cost
            itemTracker[index].cost = Math.ceil(itemTracker[index].cost * 1.15)
            priceText.set('text', `ðŸ“ ${itemTracker[index].cost}`)
            canvas.requestRenderAll();
        });

        assets.storeItems.push(group);
        canvas.add(group);
    }

    function createUpgradeButton(itemIndex, cpstext) {
        // Container Box
        const bg = new fabric.Rect({
            width: 50, // Will be resized in layout
            height: 75,
            fill: COLORS.upgradeBg,
            rx: 5, ry: 5,
            stroke: '#333',
            strokeWidth: 1
        });

        // level
        const level = new fabric.Text(`LEVEL\n${itemTracker[itemIndex].level}`, {
            fontFamily: 'Arial',
            fontSize: 12,
            textAlign: "center",
            fill: '#fff',
            left: 5,
            top: 5
        });

        // Upgrade Cost
        const upgradeCost = new fabric.Text(`ðŸ“ ${CalculateUpgradeCost(itemIndex)}`, {
            fontFamily: 'Arial',
            fontSize: 12,
            textAlign: "center",
            fill: '#fff',
            left: 0,
            top: 40
        });

        // Group them
        const group = new fabric.Group([bg, level, upgradeCost], {
            left: 225, // Set in layout
            top: 7.5,  // Set in layout
            selectable: false, // LOCKED: User can't move the button
            hoverCursor: 'pointer',
            subTargetCheck: false,
            name: 'upgradeButton'
        });

         // Add interaction
        group.on('mouseover', () => {
            bg.set('fill', COLORS.upgradeHover);
            canvas.requestRenderAll();
        });
        group.on('mouseout', () => {
            bg.set('fill', COLORS.upgradeBg);
            canvas.requestRenderAll();
        });
        group.on('mousedown', () => {
            bg.set('fill', '#e69595');
            canvas.requestRenderAll();
        });
        group.on('mouseup', () => {
            bg.set('fill', COLORS.upgradeHover);

            itemTracker[itemIndex].creditsPerSecond *= 2
            cpstext.set('text', `${itemTracker[itemIndex].creditsPerSecond}/s`)

            level.set('text', `LEVEL\n${++itemTracker[itemIndex].level}`)
            upgradeCost.set('text', `ðŸ“ ${CalculateUpgradeCost(itemIndex)}`)
            canvas.requestRenderAll();
        });

        return group
    }

    // --- LOAD MAIN ASSET ---

    // Using the generated image ID or a placeholder
    function setupMainClicker(clickerImg) {
        const fabricObj = new fabric.Image(clickerImg, {
            crossOrigin: "anonymous"
        })
        assets.wolvey = fabricObj;
        
        fabricObj.set({
            originX: 'center',
            originY: 'center',
            // === CRITICAL FIX: Ensure the object is enabled for mouse events ===
            evented: true,       
            selectable: false,
            hoverCursor: 'pointer',
            hasControls: false,
            lockMovementX: true,
            lockMovementY: true
        });

        // Click Interaction
        fabricObj.on('mousedown', function() {
            // Animate Shrink
            fabricObj.animate('scaleX', fabricObj.scaleX * 0.9, { duration: 50, onChange: canvas.renderAll.bind(canvas) });
            fabricObj.animate('scaleY', fabricObj.scaleY * 0.9, { duration: 50, onChange: canvas.renderAll.bind(canvas) });
        });

        fabricObj.on('mouseup', function() {
            // Calculate correct return scale based on layout rules
            const w = canvas.width;
            const h = canvas.height;
            const leftW = w * 0.30;
            
            // Calculate the target size based on current layout
            const targetSize = Math.min(leftW, h) * 0.6;
            const objWidth = fabricObj.type === 'circle' ? fabricObj.radius * 2 : fabricObj.width; 
            const targetScale = targetSize / objWidth; 

            // Animate Back
            fabricObj.animate('scaleX', targetScale, { duration: 100, easing: fabric.util.ease.easeOutBounce, onChange: canvas.renderAll.bind(canvas) });
            fabricObj.animate('scaleY', targetScale, { duration: 100, easing: fabric.util.ease.easeOutBounce, onChange: canvas.renderAll.bind(canvas) });

            // Score Logic
            mdpCount++;
            scoreLabel.set('text', `${mdpCount} Credits`);
            
            // Spawn Floater
            spawnFloater("+1", fabricObj.left, fabricObj.top);
        });

        fabricObj.on('mouseout', () => {
             // Calculate correct return scale based on layout rules
             const w = canvas.width;
            const h = canvas.height;
            const leftW = w * 0.30;
            
            // Calculate the target size based on current layout
            const targetSize = Math.min(leftW, h) * 0.6;
            const objWidth = fabricObj.type === 'circle' ? fabricObj.radius * 2 : fabricObj.width; 
            const targetScale = targetSize / objWidth; 

            // Animate Back
            fabricObj.animate('scaleX', targetScale, { duration: 100, easing: fabric.util.ease.easeOutBounce, onChange: canvas.renderAll.bind(canvas) });
            fabricObj.animate('scaleY', targetScale, { duration: 100, easing: fabric.util.ease.easeOutBounce, onChange: canvas.renderAll.bind(canvas) });
        });

        canvas.add(assets.wolvey);
        renderLayout();
    }

    // --- UTILITIES ---

    // Floating text effect
    function spawnFloater(text, x, y) {
        const floater = new fabric.Text(text, {
            left: x, top: y - 50,
            fontFamily: 'Arial', fontSize: 24, fontWeight: 'bold', fill: '#fff',
            originX: 'center', originY: 'center',
            selectable: false, evented: false
        });
        canvas.add(floater);
        floater.animate('top', y - 150, { duration: 1000, onChange: canvas.renderAll.bind(canvas) });
        floater.animate('opacity', 0, { 
            duration: 1000, 
            onChange: canvas.renderAll.bind(canvas),
            onComplete: () => canvas.remove(floater)
        });
    }

    // --- RESPONSIVE LAYOUT ENGINE ---
    
    function renderLayout() {
        // 1. Get Dimensions
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // Resize Canvas
        canvas.setWidth(w);
        canvas.setHeight(h);

        // 2. Define Columns
        const leftW = w * 0.30;
        const midW = w * 0.30; // Leftover for middle
        const rightW = w * 0.4;
        
        // 3. Position Backgrounds
        panelMid.set({ width: midW + leftW, height: h });
        panelRight.set({ left: leftW + midW, width: rightW, height: h });
        
        div2.set({ left: leftW + midW, height: h });

        // 4. Position Cookie (Center of Left Panel)
        if(assets.wolvey) {
            const wolveySize = Math.min(leftW, h) * 0.6; // 60% of the smaller dimension
            const scale = wolveySize / assets.wolvey.width;
            assets.wolvey.set({
                left: (leftW + midW) / 2,
                top: h / 2,
                scaleX: scale,
                scaleY: scale
            });
            assets.wolvey.setCoords()
        }

        if (assets.bgBars) {
            assets.bgBars.set({
                    left: (leftW + midW) / 2,
                    top: h / 2
            });
            // Ensure the bars are placed behind everything else
            canvas.sendToBack(assets.bgBars);
        }

        // 5. Position Score (Above Cookie)
        scoreLabel.set({
            left: (leftW + midW) / 2,
            originX: 'center',
            top: h * 0.15
        });
        cpsLabel.set({
            left: (leftW + midW) / 2,
            originX: 'center',
            top: h * 0.15 + 50
        });
        canvas.bringToFront(cpsLabel)
        canvas.bringToFront(scoreLabel)

        // 6. Position Store (Right Panel)
        storeTitle.set({
            left: (leftW + midW) + (rightW / 2),
            originX: 'center',
            top: 20
        });

        let currentY = 60;
        assets.storeItems.forEach((item) => {
            // Resize the background rect of the group to fit column
            const bgRect = item.getObjects()[0];
            const targetWidth = rightW - 20;
            
            // Note: modifying objects inside a group can be tricky in Fabric
            // We scale the whole group to fit the width approximately
            // Or we just center it. Let's Center it for simplicity.
            
            item.set({
                left: (leftW + midW) + (rightW / 2),
                top: currentY,
                originX: 'center',
                originY: 'top'
            });
            
            // Simple scale to fit if column is too small
            if (rightW < 300) {
                const scale = (rightW - 20) / 280;
                item.scale(scale);
            } else {
                item.scale(1);
            }

            // Increment Y based on item height (including scale)
            currentY += (item.height * item.scaleY) + 10;
        });

        canvas.requestRenderAll();
    }
    
    preloadAssets(assetUrls).then(loadedAssets => {
        console.log("All assets finished loading!", loadedAssets);

        // Main Clicker
        setupMainClicker(assets.images["wolvey"]);

        // Create some dummy store items
        createStoreItem("ROOT", 15, 0.1, assets.images["meme1"], "I have become ROOTS Eternal", 0);
        createStoreItem("MEME2", 100, 1, assets.images["meme2"], "funny quote", 1);
        createStoreItem("MEME3", 1100, 8, assets.images["meme3"], "funny quote", 2);
        createStoreItem("MEME4", 12000, 47, assets.images["meme4"], "funny quote", 3);
        createStoreItem("MEME5", 130000, 260, assets.images["meme5"], "funny quote", 4);

        assets.bgBars = createSpinningBars()
        renderLayout();
    })
    // Listen to resize
    window.addEventListener('resize', renderLayout);

    let lastTimeStamp = -1
    let lastCreditCount = 0
    function Update(timestamp)
    {
        // Update score label
        scoreLabel.set('text', `${Math.floor(mdpCount)} MDP Credits`);

        // Update credits per second label
        if (lastTimeStamp != -1)
        {
            if (timestamp - lastTimeStamp > 250)
            {
                const deltaTimeSeconds = 1000 / (timestamp - lastTimeStamp)
                const totalCreditsPerSecond = (mdpCount - lastCreditCount) * deltaTimeSeconds;
                cpsLabel.set('text', `per second: ${Math.floor(totalCreditsPerSecond)}`);

                lastTimeStamp = timestamp
                lastCreditCount = mdpCount
            }
        }
        else
        {
            lastTimeStamp = timestamp
            lastCreditCount = mdpCount
        }
        canvas.requestRenderAll();
        window.requestAnimationFrame(Update)
    }
    window.requestAnimationFrame(Update)
</script>
</html>